<pre>
&&运算符的第一个操作数是false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是false。

document.write输出的是html，在html中用<br/>来表示换行，而\n属于javascript alert("abc\ndef"); alert参数是要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本） alert的参数是javascript中的字符串，javascript中适用\n来表示换行。


脚本语言与非脚本语言的区别：
	非脚本语言编写的程序经过编写-编译-链接-运行                         脚本语言只需经过编写-运行 即不需编译成二进制以文本形式存在；不能独立运行，需其他语言调用执行
JS作用:
	动态改变网页内容(HTML) 动态改变网页样式(CSS) 验证表单数据 响应事件

嵌入JavaScript代码的三种方式：                                                                    1.写在script标签中  2.直接放在HTML标签中(内嵌式) 3.以外部文档的方式连接到当前HTML文档中(外部引用)注：引用时建议放在head位置，且script标签内不可有任何内容

document.write() 括号内的内容会被输出。(作用相当于pre，仅是猜想)
alert() 弹出一个对话框

在一个HTML文档中使用多个script标签嵌入JS语句时,标签里的内容相互关联
字符串可以用“+”进行连接

变量命名规范：
	1.以字母、数字、下划线或美元符号组成,不得包含空格、标点、运算符等符号
	2.不得以数字开头   3.不能是系统关键字   4.区分大小写    5.命名最好有意义
变量声明关键字“var” 同时声明多个变量需用逗号分隔开
变量作用范围：
	1.全局变量 函数体外定义,整个文档都可使用
	2.局部变量 函数体内定义,只在函数体内有效
	3.省略“var”声明的变量,无论在函数体内还是体外均为全局变量
常用转义字符：  换行\n  回车\r  退格\b  反斜杠\\  双引号\“
typeof(查询数据类型): 其返回值可有 undefined boolean number string object function


	转义字符用在document.write()中无效 要换行用br 转义字符可用在alert()中
数值型数据 Number:JavaScript只有一种数字类型,就是number型 数字可以带小数，也可以不带
Boolen类型数据只有两个值：true false  其他类型值转化为布尔规则如下：
	Number: 任意非零为true 0和NaN为false
	string:所有非空字符串转化为true  ""(空字符串)转化为false
	object的任何对象都会转化为true
	在javascript中只要逻辑表达式不返回undefined和null,就都是真的,即undefined和null会转为false。
Null类型:空值 值：null  用途：通过将变量的值设置为null来清空变量 
	和undefined的区别 null已定义并初始化为null undefined:未定义，或未初始化
Array:数组 创建方式： 1、var a=[value1,value2] 2、var b=new Array(value1,value2)

object:对象 在javascript中所有的对象都继承自object
	形式：var c={name1:value1,name2:value2} 对象没有赋值的属性,该属性值为undefined
	用typeof测试数据类型时,null和Array都会返回object，因为他们都属于特殊的对象

算数运算符 + -：正负得负 负负得正 正正得正 负正得负
递增递减运算符： ++  --
	未赋值时自增或自减 如 a++ ++a 效果一样
	赋值时自增或自减 如 var b=a++ 即先将a的值赋给b,a再自增(即b=a,a=a+1) 
	若 var b=++a 即a先自增为a+1,再将a+1赋值给b(即a=a+1,b=a) (这样理解:等号后为a,那就先赋值,等号后为+,那就先运算)
比较运算符：
	相等运算符 ==  判断两个操作数是否相等，不同类型的数据会自动转换为相等的数据类型再做比较
	等同运算符 === 全等 两个操作数的类型和值完全一致
	不等于 ！=
	不等同 ！==
逻辑运算符： && 与     || 或    ！非
条件运算符： 条件？语句1：语句2   条件为真执行问号后的语句1否则执行冒号后的语句2
true为1 false为0

数值字符串和数值比较时，字符串会自动转化为数值再进行比较
两个都为字符串则比较首个数字
字母字符串会转换成对应的ASCII码进行比较

if语句： 1、if  2、if else  3、if  else if  else
if中的表达式会自动转换成布尔值
switch语句： switch(条件){ case value1:执行的语句;break; case value2:执行的语句;break;default:执行的语句;}
for循环：
	for(语句1;语句2;语句3){被执行的代码块}
	语句1在循环前开始执行,然后执行语句2,若语句2为true则执行代码块否则结束循环，语句3在代码块执行后执行，语句1和3均可省略(其实省略后需把它加进代码块)。语句2不可省,否则会死循环.
while       do while
continue:结束本次循环,重新开始下一次循环  break：跳出最近的循环体，结束循环


函数：
函数的声明和调用：
	使用关键字function声明,必须是小写;						函数本身不会自动运行,只有调用时才会执行; 
	可以先调用后声明
	不在同一个script中仍可调用当函数遇到第一个return后将终止后面的代码,会跳出函数
  函数内部属性：
	arguments对象: 将函数中的所有参数存储在arguments中,相当于一个数组 例如arguments[0]表示函数第一个参数  可以通过arguments动态添加参数  arguments.length检测函数参数的个数（注：argument表示的是实参）

	this一般指当前作用域下的对象
	this：
	  1.在函数外部使用this，this指的是window对象； 2.在某些情况下的函数内部调用this，this指的也是window对象； 3.函数被new来调用，那么函数内部的this是new 关键字新创建的上级对象； 4.函数作为某个对象的方法调用，函数内部的this指的是这个上级对象； 5.事件监听函数内部的this，指的是触发这个事件的元素。
  函数方法：每个函数都包含两个非继承而来的方法 apply()和call() 这两个方法	都是在特定的作用域中调用	  函数,实际上等于设置函数体内this对象的值	
  apply(函数运行作用域,[传参]) 
  call(函数运行作用域,参数1,参数...)本质上都一样,只是传参形式不同	这两种方法常用来扩充函数运行的作用域即改变函数中this的指向而非单纯传参
基本数据类型和引用类型：
  基本类型值：undefined Null Boolean Number String	这些类型在内存中占用固定大小空间,值保存在栈空间中,按值访问
  引用类型：对象 数组 函数	引用类型保存对象多少不固定,即在内存中空间不固定,但内存地址固定,存储在堆内存中,存储的是内存地址	变量复制时,基本类型复制的是值本身,系统会再为其分配内存空间。  引用类型复制的是地址

  函数的参数都是按值传递的：即定义一个全局变量a,在函数内部引用并改变了a值,但在函数外部输出a时,a仍为最初定义的值。（var a=5;function sun(b){b+=10;return b;} alert(sun(a)) alert(a) ）

内存管理：
	内存生命周期：1.内存分配 当申明变量、函数、对象时系统会自动为其分配内存
		2.内存使用 即读写内存，也就是使用变量、函数等
		3.内存回收 使用完毕垃圾回收机制自动回收不再使用的内存
	垃圾回收算法：核心思想是如何判断内存已不再使用 

局部变量(临时变量)存在栈内存，全局变量存在堆内存
没引用时，调用函数，栈空间会分配一小块内存给他，函数里的变量会储存在栈空间里，调用完毕了，栈空间会释放掉。

JS内存管理注意事项：
	1.避免不必要的全局变量 当变量被定义在全局作用域中,默认情况下不会被销毁回收,会存在于堆内存中直至页面关闭。
	2.及时解除不再使用的变量将其赋值为null 浏览器会每隔一段时间检查回收内存
	3.合理使用函数 函数中局部变量执行结束后会自动释放内存

全局函数(在这仅指JS中系统已封装好的函数)：全局函数和属性可用于所有内建的JS对象。全局函数又叫顶层函数或系统函数。
	isNaN()检查参数是否是非数值
	String()把对象值转换为字符串
	Number()把对象值转换为数字
	eval()解析某个字符串并执行其中的代码,该方法只接受字符串为参数
	escape()编码字符串(返回已编码的string副本)该方法不对ASCII字母和数字(a-z A-Z 0-9)及“+ - * / @ . _”共69个字符编码,主要防止特殊字符造成计算错误								unescape()对"escape()"编码的字符串进行解码						encodeURI()把字符串编码为URI,其中有82个字符不对其编码,防止特殊字符造成URI传递错误	decodeURI()解码某个编码的URI



匿名函数：没有名字的函数
  创建方式：1.将函数赋值给一个变量(此方式和普通创建函数相似)									2.(函数)(参数)注：当为有参函数时第二个括号才写要传入的参数
闭包：有权限访问另一个函数作用域中变量的函数 本质上闭包是连接函数内外部的桥梁
  创建方式：在一个函数中嵌套另一个函数
	function fun(){
		var a=12;
		return function(){
		alert(a);
	}
}

  外部要想访问到a,访问方式：1.fun()() 	2.var str=fun(); str()
	方式1每次调用fun时会执行函数里的所有内容,从上到下依次执行,即a每次都会初始化  方式2每次调用时只是调用的嵌套函数,a只会初始化一次,嵌套函数用到a时只会向上搜索


方式1和2调用有区别
方式1：
function fun(){
	var a=100;
	alert('调用一次弹一次');
	return function(){
		a++;
		alert(a);
	}
}
fun()();
fun()();
每次调用时整个函数从头开始运行,a每次都被初始化,会弹出两次“调用一次弹一次” 故调用两次a均为101

方式2
function fun(){
	var a=100;
	alert('只弹一次');
	return function(){
		a++;
		alert(a);
	}
}
var b=fun();
b();
b();
b=null;
第一次调用时函数从头开始运行,a会被初始化,再次调用a不再被初始化,“只弹一次”不会再次弹出，即以后调用的是里面的匿名函数,故a会累加,第一次101,第二次102
不再使用将其赋值为null,避免占用内存

用途：通过闭包可以访问局部变量	可以让这些变量的值始终保存在内存中	优点：避免了使用全局变量,命名冲突	缺点：闭包里作用域返回的局部变量资源不会被立刻销毁回收,可能会占用更多内存,过度使用造成性能降低


循环函数中的匿名函数和闭包
1.循环函数中的匿名函数
function fun(){
	var arr=[];
	for(var i=0;i<5;i++){
		arr[i]=function(){
			return '元素'+i;
		};
	}
	return arr;
}
var bn=fun();
alert(bn.length);
alert(bn);
alert(bn[0],bn[1],bn[2],bn[3],bn[4]);
alert(bn[0]())
此时得到结果为“5”、5个匿名函数、5个'元素i'以及“元素5”
因为闭包内的函数没有立即执行，循环结束后得到的只是5个匿名函数，此时“i”由于循环结束变为了“5”，当再调用时调用的已经是匿名函数了，匿名函数的值为“元素i”,此时i已经变为了“5”

function fun(){
	var arr=[];
	for(var i=0;i<5;i++){
		arr[i]=function(){
			return '元素'+i;
		}();
	}
	return arr;
}
var bn=fn();
alert(bn)
此时会得到数组“元素0-4” 因为在每次执行循环时函数都立即执行,函数参数按值传递，会及时的将值return出去

2.循环函数中的闭包
	不传参不立即执行
function fun(){
	var arr=[];
	for(var i=0;i<5;i++){
		arr[i]=function(){
			return function(){
				return '元素'+i;
			}
		}
	}
	return arr;
}
var bn=fn();
alert(bn[0]());
alert(bn[0]()());
得到的结果依然为一个匿名函数和“元素5” (注意bn是一个集合，不可写成bn(),而是bn[0-4]())

	传参并立即执行
function fun(){
	var arr=[];
	for(var i=0;i<5;i++){
		arr[i]=function(n){
			return function(){
				return '元素'+n;
			}
		}(i);
	}
	return arr;
}
var bn=fun();
for(var i=0;i<5;i++){
	alert(bn[i]);
	alert(bn[i]())
}
此时会得到最里面的匿名函数“function(){return '元素'+n}”和数组“元素0-4”
注意此时的“n”只是一个形参 在“i”传参并立即执行时，由于函数按值传递，第一次循环时“i”为0,拷贝0赋值给形参“n”,第二次循环时“i”为1,拷贝1赋值给形参“n”,即在每次调用匿名函数时都会传入变量“i”,并将变量“i”的当前值传给形参“n”，即每次调用匿名函数都会在其内部创建一个局部变量“n”并赋值，(这就是闭包可将局部变量保存在内存中)


闭包中的this:匿名函数的执行具有全局性,this通常指向window
	访问闭包中的变量：1.使用call()和apply()方法对象冒充强制改变this指向 2.将this赋值给变量,通过闭包访问这个变量

1.对象冒充
var name='window';
var obj={
	name:'myobj',
	get:function(){
		<!-- 若在此处添加this 则this作用域在匿名函数内，this指向obj,因为匿名函数是obj的对象-->
		return function(){
			return this.name; <!-- 此处this的作用域仅在闭包内,指向get，因为是get的方法 -->
		}
	}
}
alert(obj.get()())
结果为“window” 此时在window的作用域内调用get方法，obj的“name”属性在get方法上面，并没有初始化“name”,故指向window的name属性
alert(obj.get().call(obj))
结果为“myobj” 此时使用了对象冒充相当于在obj作用域内调用get方法，故指向obj的name属性

2.this赋值给变量
var name='window';
var obj={
	name:'myobj',
	get:function(){
		var selfname=this;
		return function(){
			return selfname.name;	
		}
	}
}
alert(obj.get()())
结果为“myobj”
调用get方法 会将“selfname=this”初始化，由于this关键字，一层一层向上一级作用域寻找



块级作用域又叫私有作用域，但JS没有块级作用域的概念，这意味着块语句(比如for语句)中定义的变量不会因为离开块(离开for)就失效。
块级作用域：使用let声明的变量,只在{}中有效,常用于for循环中等

如何模仿块级作用域：写一个匿名函数并让其立即执行,这样外部就访问不到函数内部的变量了即(function)()
	优点:1.只要是在匿名函数中定义的变量均会在函数执行结束时销毁（最重要的一点）
		2.尽可能少向全局作用域中添加变量和函数，避免了命名冲突
		3.使用块级作用域不会扰乱全局	
		4.在全局作用域中使用块级作用域减少闭包带来的内存消耗


JS没有私有属性概念，所有的属性都是公用的
私有变量：在任何函数中定义的变量都是私有变量，因为不能在函数外部访问
	它包括局部变量、函数的参数、在函数内部定义的其他函数
特权方法:内部创建一个闭包，闭包可以访问私有变量，因此创建用于访问私有变量的公用方法称作特权方法
function people(){
	var name='张三';
	this.getName=function(){
		return name;
	}
}
var p1=new people();   <!-- 注意需用new -->
alert(p1.getName());

静态私有变量：
创建步骤：1.创建私有作用域 2.定义私有变量或函数 3.定义构造函数或特权方法
(function(){            <!-- 创建私有作用域 -->
	var name='张三';     <!-- 定义私有变量 -->
	User=function(){}; <!-- 定义构造函数 注意此时user为全局变量 -->
	User.prototype.getName=function(){
		return name;
	}
	User.prototype.setName=function(value){
		name=value
	}
})()
var p1=new User();
alert(p1.getName()); <!-- 张三 -->
p1.setName('李四');
alert(p1.getName()); <!-- 李四 -->

这种方式创建的变量由于使用原型而实现共享，此时的User可被多个实例共享，但也由于共享导致实例没有自己的私有变量




//
箭头函数的this指向的是上一级作用域下的this
//

文档状态：
	readyState:uninitialized还未开始载入	loading载入中	interactive已加载,可以开始交互	complete加载完成




对象：
对象由属性和方法组成：属性的实质是变量，方法的实质是函数
面向对象：不用去了解对象内部构造就可去使用它

创建对象的方式：
	1.基本模式 缺点：创建多个对象就会比较繁琐 实例与原型之间看不出联系 
	2.工厂模式(函数):即在一个函数内部创建一个对象,每次创建新对象时只需调用此函数并传入相关参数即可 (注：在函数内部需将创建的对象return出去,即完工后的出口) 
	缺点：创建的实例无内在联系，不能反映出是同一个原型对象的实例 
	创建对象时未使用new关键字 
	资源浪费 每生成一个实例都会增加一个重复的内容
	工厂模式
	function create(name,weapon) {
		var per=new Object();
			per.na=name;
			per.wea=weapon;
			per.run=function (argument) {
				return this.na+'的武器是'+this.wea;
		}
		return per; //此步看做出厂 必须有
	}
	var p1=create('孙悟空','金箍棒');
	alert(p1.run());
	
	3.构造函数：即创建一个传参函数，在函数内部使用'this.变量'来表示变量，调用时this就会绑定在实例对象上，因此不需像工厂模式那样return (专门用来生成对象的函数,使用new来调用，与普通函数区别就在于调用时是否使用了new)
	在调用时需要用new关键字调用传参（可以理解为用new将一个创建好的函数变为对象，此时只需传参调用即可）
	注：工厂模式和构造函数模式每次实例化对象都会给对象创建新的地址,即函数拷贝到每一个实例中，而不是引用地址 造成资源浪费

	function create(name,weapon) {
		this.na=name;
		this.wea=weapon;
		this.run=function() {
			return this.na+'的武器是'+this.wea;
		}
	}
	var p1=new create('孙悟空','金箍棒');
	alert(p1.run());

	call()和apply()方法做对象冒充 两种方法本质类似,只是传参方式不同而已
	var p2=new Object();
	create.call(p2,'妖怪','葫芦');
	create.apply(p2,['妖怪','葫芦']);
	alert(p2.run());

	instanceof验证实例对象与原型对象之间的关系 用法：A instanceof B 返回值true/false

	4.prototype原型模式:JS规定，每一个构造函数都有一个prototype属性指向另一个对象，这个对象的所有属性和方法会被构造函数的实例继承。因此可以将那些不变的属性和方法直接定义在prototype对象上。
	此方式定义，实例化对象时prototype对象就可以被引用而非拷贝，节省资源
	
  方式1：
	function create(){};
	create.prototype.na='喽啰';   <!-- 此时创建的字面量直接指向构造函数create() -->
	create.prototype.wea='大刀';
	create.prototype.run=function(){
		return this.na+'的武器是'+this.wea;
	}
  方式2
  	function create(){};
  	create.prototype={
  		constructor:create,  <!-- 强制指向create()不加此行代码也可,就是和方式1指向不同 当需该指向则加 -->
		na:'喽啰',     <!-- 此时创建的字面量指向创建对象create.prototype,故添加constructor -->
		wea:'大刀',
		run:function(){return this.na+'的武器是'+this.wea}
	} 
	var p1=new create();
	alert(p1.run())
	说白了原型模式就是多了一个prototype属性，将共用的属性及值封装到prototype中，用时直接调用即可。
	isPrototypeOf属性用来判断某个prototype对象和实例的关系，用法：create.prototype.isPrototypeOf(p1)
	hasOwnProperty属性用来判断某个实例是否有自己的prototype，用法：p1.hasProperty.('na') 如果p1的'na'属性是继承自prototype,而非自已的本地属性则返回false
	in运算符判断某个实例是否有某个属性，不管它是自己的本地属性还是继承的prototype 用法：'na' in p1

	缺点：1.构造函数不能传参，使用原型不能通过给构造函数传参来初始化实例属性
		2.方法(即内部创建的函数)和对象均可被共享，但对象一般很少被多个实例共享，实例一般有自己的对象。

	5.构造函数和原型组合模式
	function create(name,weapon){
		constructor:create;
		this.na=name;
		this.wea=weapon;
	}	
	create.prototype={
		run:function(){returu this.na+'的武器是'+this.wea};
	}
	<!-- 写成这样更好理解create.prototype.run=function(){return this.na+'的武器是'+this.wea} -->
	var p1=new create('喽啰',['大刀',长矛]);
	alert(p1.run());

	和构造函数相比就是把共用属性放在了prototype属性上,调用时引用此属性而不是像构造函数那样复制,节约资源，除此外无差别。
	瑕疵：封装性差了点,因为分成了两个而非一个。

	6.动态原型模式
	function create(name,weapon){
		this.na=name;
		this.wea=weapon;
		alert('开始初始化');
		create.prototype.run=function(){return this.na+'的武器是'+this.wea};
		alert('结束初始化');
	}
	var p1=new create('喽啰','大刀');
	var p2=new create('小兵','长矛');
	alert(p1.run());
	alert(p2.run());
	多个对象实例化时此时会出现问题,即在方法调用前后需初始化,但只初始化一次即可,此时这种写法会造成每个实例在创建时都开始进行初始化,即即使未调用方法依然会弹出初始化。

	解决办法：
	function create(name,weapon){
		this.na=name;
		this.wea=weapon;
		if(this.run!='function'){
			alert('开始初始化');
			create.prototype.run=function(){return this.na+'的武器是'+this.wea;}
			alert('结束初始化');
		}
	}


with语句：引用某个特定对象中已有的属性
	var people={
		name:'张三',
		age:30;
	}
	function wr1(){
		var str1="姓名"+people.name;
		var str2="年龄"+people.age;
		alert(str1+str2);
	}
	function wr2(){
		with(people){
			var str1='姓名'+name;
			var str2='年龄'+age;
			alert(str1+str2);
		}
	}
此时wr1()结果等同于wr2()


继承：（父类又叫超类、基类）
  子类的实例可以共享父类的方法 子类可以覆盖或扩展父类的方法  子类和父类都是子类实例的类型
  继承方式：
	1.对象冒充(又叫构造函数绑定) 原理：使用对象冒充（call或apply方法，实质是改变this指针指向）继承基类
	function monkey(type,home){
		this.ty=type;
		this.ho=home;
	}
	function magic(hp){
		this.h=hp;
	}
	function magic_monkey(type,home){
		monkey.call(this,type,home);    //冒充第一个父类的对象
		magic.call(this,hp);            //冒充第二个父类的对象
		this.skill='七十二变';
	}
	var wukong=new magic_monkey('猴子','花果山','生命值');
	alert(wukong.ty);
	alert(wukong.h);
	alert(wukong.skill);
	
	一个子类可继承多个父类，注意传参顺序及数量
	缺点：由于是构造函数,函数传参是按值传递造成资源浪费

	2.原型链继承
	function monkey(){};
	monkey.prototype.ty='猴子';
	monkey.prototype.ho='花果山';

	function mon(){};
	mon.prototype=new monkey();  //此处相当于清空了mon的原prototype属性,再将monkey的prototype赋值给mon
	mon.prototype.skill='七十二变';  //添加新属性需在清空并赋值后添加,否则仍会被清空
	var wukong=new mon();
	alert (wukong.ty);

	缺点：只能继承一个父类的prototype属性，因为前者会被后者覆盖

	3.混合继承
	用构造函数继承父类的对象，用原型链继承父类的方法
	function monkey(type,home){
		this.ty=type;
		this.ho=home;
	}
	monkey.prototype.say=function(){alert('我很快乐');};
	
	function mon(type,home){
		monkey.call(this,type,home)
	}
	mon.prototype=new monkey();
	var wukong=new mon('猴子','花果山');
	alert(wukong.ty);
	alert(wukong.ho);
	wukong.say();



创建对象的方法:
	1、通过new关键字 var A=new Object(); O要大写
						A.name='逍遥';
						A.age=18;
	2、 var A={};
			A.name='逍遥';
			A.age=18;
	3、var A={name:'逍遥',age:18}
访问对象方式：
	1、alert(A.name)
	2、alert(A["name"])
delete运算符可以删除对象：delete A.name
创建数组(方法同对象)：
	1、var A=new Array("逍遥","郎君")
	2、var A=["逍遥","郎君"]  new关键字可省略
	3、length可获取也可创建数组长度 var A=new Array(4)/alert(A.length)
A.push("武魂")   将新元素添加到数组尾部
delete A[1]      删除指定的数据(注意：需用中括号和数字表示)
A.pop()         删除末尾元素,该方法会返回删除的元素
A.shift()       删除顶端元素
A.unshift()     在数组顶端添加元素,该方法会返回新数组的长度(不建议使用它因为IE会出错)
A.toString()    将数组转化为字符串
A.join('++++')  数组转化为以“++++”连接的字符串
A.reverse()     数组中的元素逆序

A.sort()        数组中的元素从小到大排列(按照ASCII码进行排序)     
A.sort(name) 自定义给数组排序
	function name(a,b){return a-b} (自定义一个函数,传入两个参数进行比较,A调用此函数,A中的元素挨个充当a和b,写成a-b为升序,写成b-a则为降序)也可这样理解:写成a-b即第一个参数减第二个参数,写成b-a则是第二个参数减第一个
	实际为根据 return返回值来确定顺逆序，返回值为正则降序，为负则升序

A.concat(数组/元素) 将数组/元素和数组A合并为一个新的数组
A.splice(参数1,参数2,参数3) 原数组会被改变 参数1表示起始位置(从0起算),2表示切取的个数,3表示插入的个数(可选参数,若有则表示替换，若无则表示切取)   
	如A.splice(1,0,"西瓜") 表示在A的第2位置,切掉0个,插入“西瓜”
	如A.splice(1,2,"武","魂") 表示在A的第2位置,切掉2个,插入“武” “魂”,相当于将原来的第三四位置的元素以新元素替换掉
A.slice(参数1,参数2) 原数组不会被改变 参数1表示起始下标位置切取时包含在内,参数2表示结束位置不包含在内
	若没有第二个参数则表示切到末尾
	A.slice(1,5)表示从A中切取第2至第5(不是6)位置元素,切掉的形成一个新数组,原数组不改变
in和for in
	in检测对象是否具有某一特定属性
	对于数组A() in表示遍历A中的元素
	对于对象A{name:value} in表示遍历A中的属性,而非属性值
	例: for(x in A){document.write(A[x])}
	无论是数组还是对象,x代表的是位数,遍历时从第零位遍到末位,即遍历的是位数而非元素


函数的递归就是自己调用自己,如计算阶乘就是
		function jiecheng(n) {
			if (n==1){
				return 1;
			}
			else{
				return n*jiecheng(n-1);
			}
		}
		alert(jiecheng(2));

关于cookie：cookie是保存在客户端的变量，当计算机请求页面时，浏览器就会发送cookie，下次再发访问同一页面时，服务器先查看cookie，根据cookie资料判断来访者，进而发送内容。
目前大部分浏览器可在客户端生成和读取cookie，但Chrome不支持，需在服务端。

创建cookie：document.cookie=''; 可连续创建多个且后面的不会覆盖前面的
参数： “属性及值” 示例：document.coolie='name=张三'
       expires(过期时间) 示例：document.coolie='name=张三;expires='+date
		path(路径：默认为“/”) 登录某一网站，该网站的cookie信息可在该网站任一页面查看，若在某一页面设置cookie路径，则该页面的源代码需放置在指定的路径下再打开才能查看cookie 示例：var str='/D:/demo'; document.cookie='name=张三;path='+str
	   domain 设置cookie的有效域名，一般默认值，即绑定当前域名，在本地测试无效，需用服务器测试
	   secure 设置传输协议，默认为普通http协议传输，若设置了则为https安全协议传输 示例：document.cookie='name=张三;secure'


cookie函数的封装
<script>
	function dday(str) {
		var day=new Date();
		day.setDate(day.getDate()+str);
		return day;
	}
	function setCookie(key,value,str) {
		document.cookie=key+'='+value+';expires='+dday(str);
	}
	setCookie('name','逍遥郎君',10);
	setCookie('age',24,10);
	setCookie('sex','man',10);

// cookie的读取 用到split()函数将字符串分割为数组
	var strings=document.cookie;
//因为cookie每个值冒号后都有一个空格，此冒号后的空格是为了将其抵消掉，否则cookie字符串被分割后的数组每个前面都有一个空格(第一个除外) 或者在调用函数输入数据时在每个数据前加个空格(不推荐此法) 
	var attstr=strings.split('; ');  
	function getCookie(key) {
		for (var i = 0; i < attstr.length; i++) {
			var att=attstr[i].split('=');
			if (key==att[0]) return att[1];
		}
	}
	alert(getCookie('name'))
</script>

cookie的限制：
内存仅有4K，能保存数据的数量有限，大概保存20-50条信息，不同浏览器有差异
有些信息不适合，比如银行卡号

json：json语法是JS对象表示法的语法的子集
json实际是个字符串(注：在json中不可写注释,因为它本身就是字符串，即使是注释也会读取)
语法规则：数据在键值对中 由逗号分隔 花括号保存对象 方括号保存数组
json值：number(整数或浮点数)/strings(键值对均在双引号中)/boolean/Array/object/null

json解析器只会识别文本并不执行
语法：var ob=JSON.parse(myjson,参数2)
参数2为匿名函数可选 (注匿名函数需有两个形参,执行时会将json的键和值传入)

序列化：与解析相反，将几组对象转换为json数据(即字符串)
语法：var ob=JSON.stringify(myjson,参数2,参数3)
参数2可选,用法同上,若不选可写为“null”
也可设置为要过滤的键值,如“['name','age']”会将其他的键值筛选出去再序列化

参数3可选,即如何排版,可写为“数字或字符”，如(“4”或“**”)即在每个键值对的前面加上4个空格或2个“*”


Ajax基本用法：
1.创建XMLHttpRequest对象 语法：var myAjax=new XMLHttpRequest()
2.向服务器发送请求：使用open()和send()方法
  open(method,url,async) 
  	method请求类型：get/post  url:文件在服务器上位置	 async:true(异步 通常为异步)/false(同步)
  send(string) string仅用于post请求
3.服务器响应
  responseText 接收服务器返回字符串形式的响应
  responseXML 接收服务器返回XML形式的响应并解析
4.XMLHttpRequest三个重要属性：
  onreadystatechange存储函数(或函数名)每当readyState属性改变时触发此函数
  readyState:存有XMLHttpRequest的状态,从0到4发生变化 0:请求未初始化 1:服务器已建立连接 2:请求已接收 3:请求处理中 4:请求已完成且响应已就绪
  status:状态码 如 200/404等		statusText状态码对应的文本,如404对应not found
示例：
var myAjax=new XMLHttpRequest();
myAjax.open('get','test.txt',true);
myAjax.send(null);
myAjax.onreadystatechange=function(){
	if(readyState==4){
		if(myAjax.status==200){
			alert('success')
			alert(myAjax.responseText)
		}
	}
}

同步请求和异步请求
同步：提交请求后服务器只能做这一件事,当处理完才可做下一件 (使用场景:当前请求结果是下一步请求前提)
异步：浏览器可同时做多件事





创建日期的四种方法：
	var datename=new Date() 无参数返回当前时间
	var datename=new Date(milliseconds) 参数为毫秒返回自1970年加上毫秒数的总日期
	var datename=new Date(year,month,day) 返回参数中的年月日,时分秒均为0 (注意:月份是从0开始的,实际输出是month加1)
	var datename=new Date(year,month,day,hour,minter,second) 返回参数中的年月日时分秒

获取时间的几种方法:先创建好 var datename=new Date() 
	date1=datename.toString() 获取当前时间,以年月日时分秒输出(24小时制符合外国方式)
	date1=datename.toDateString() 获取当前时间的年月日部分
	date1=datename.toTimeString() 获取当前时间的时分秒部分
	date1=datename.toLocaleString() 获取当前时间以年月日时分秒输出(12小时制且符合国人方式)
	date1=datename.toLocaleDateString() 获取当前时间的年月日部分(符合国人方式)
	date1=datename.toLocaleTimeString() 获取当前时间的时分秒部分(符合国人方式)
	date1=datename.valueOf() 当前时间减去1970年的毫秒数

	date1=datename.getTime() 当前时间减去1970年的毫秒数
	date1=datename.getFullYear() 获取当前时间的年
	date1=datename.getMonth() 获取当前时间的月
	date1=datename.getDate() 获取当前时间的日 (1-31)
	date1=datename.getDay() 获取当前时间的周几 (0-6)  (注意:需自己写函数表示"周")
	date1=datename.getHours() 获取当前时间的小时 (0-23)
	date1=datename.getMinutes() 获取当前时间的分 (0-59)
	date1=datename.getSeconds() 获取当前时间的秒 (0-59)
	date1=datename.getMilliseconds() 获取当前时间的毫秒 (0-999) (注意"s"小写)

自定义设置时间(设置时语法同上稍有差异)
	先对datename传入参数,再用一个变量去接收,然后输出变量
	var datename=new Date()
	datename.setMonth(5)
	date1=datename.getMonth()
	alert(date1)

	datename.setFullYear() 设置当前时间的年
	datename.setMonth() 设置当前时间的月
	datename.setDate() 设置当前时间的日 (1-31)
	datename.setDay() 设置当前时间的周几 (0-6) (注意:当年月日都设置好后周几已经确定了,此时无法再自定义)
	datename.setHours() 设置当前时间的小时 (0-23)
	datename.setMinutes() 设置当前时间的分 (0-59)
	datename.setSeconds() 设置当前时间的秒 (0-59)
	datename.setMilliseconds() 设置当前时间的毫秒 (0-999) (注意"s"小写)

Math数
	Math.PI()
	Math.ceil()  数值上舍入 (小数舍去个位进一)
	Math.floor() 数值下舍入 (小数舍去)
	Math.round() 四舍五入取整 
	Math.random() 0-1之间的随机数 [0,1)含0不含1
	
	要返回某一区间的随机数,有规律可循
	return Math.floor(Math.random()*(high-low+1)+low)
	如:(3,13)     return Math.floor(Math.random()*(13-3+1)+3)

	Math.max(a,b,c,d,e..) 
	Math.min(a,b,c,d,e..) 
	Math.abs(x)  绝对值 
	Math.pow(x,y) x的y次方

字符串与数字转换:
	new String()    通过new关键字创建字符串对象
	A.length        返回A的长度
	A.toString()    将数值A转换为字符串
	A.toString(x)   将数值A转换为x进制的整数
	parseInt(A)     将字符串类型的A转换为整数
	parseFloat(A)   将字符串类型的A转换为浮点数
	Number(A)       将字符串类型的数值A转换为数值
字符串对象常用方法:
	str.charAt(x)     返回字符串str在x位置的字符  (at即在..位置的意思)
	str.charCodeAt(x) 返回在x位置的字符的unicode编码 
	str1.concat(str2) str1连接str2
	str.slice(n,m)    提取str中[n,m)之间的字符串  (slice适用于字符串和数组)
	str.substring(n,m)   效果同slice 当n、m为负值时效果不同  (只适用于字符串不适用于数组)
	str.substr(n,m)   从n开始,提取m个字符
	str.split()        把字符串分割为字符串数组
	str.split(x,number)       str中有x,则以x为分割符将其分割为字符串数组,否则str变为只有它本身的字符串数组(相当于未分割,只是变为了数组而已 number为可选参数,即将字符串分为几个数组 若number小于理论,后面的则被去掉)

	当提取的参数为负值时:
		var str="12345678"
		str.slice(1,-3)     str长度为8,-3加8为5,则提取str中[1,5）的数据
		str.slice(-6,-3)    -6+8,-3+8 则提取str中[2,5)的数据
		str.slice(6,-3)     此时6大于5,提取为空

		str.substring(3,-2) 只要参数为负值,此时均为0,取值区间变为[0,3) 若两参数均为负则为[0,0)取空
		str.substring(-2,3) 效果同上

		str.substr(-5,3)    从右向左数到第五个字符,从此位置向右取3个字符 若第二个参数为负则取空 (注意:因为第二个参数含义代表取几个字符)
	
	indexOf()检索字符串,返回某个字符首次出现的位置 若无返回-1
	lastIndexOf()从后向前检索
	toLowerCase()转为小写
	toUppererCase()转为大写

JS中的字符串是不可变的 string类定义的方法都不能改变字符串的内容,string方法返回的是全新的字符串而非改变原字符串

几个关于搜索匹配的方法：
1.search 	str.search('i') 找到i则返回i的位置索引,否则返回-1 (注：其只查找首次出现的单个字符)
2.match 	str.match('string') 找到string则返回string,否则返回null
3.replace 	str.replace('javascript','js') 前一个字符串被后一个替代 若前一个字符串不存在则返回str
4.split 	str.split(i,number) 将str用i分割为number个数组,number可选 i会消失


正则表达式：
创建方式：
1. 使用new关键字如：var st=new RegExp(pattern,attributes) 
2. 使用字面量如： var st=/pattern/attributes
pattern指表达式的模式或其他正则 attributes指修饰符

修饰符： i不区分大小写 g全局匹配 m多行匹配
方括号[]:
  [abc]查找方括号内的任何字符
  [^abc]查找不在方括号内的任何字符
  [0-9]、[a-z]、[A-Z]、[A-z]查找区间内的字符

元字符：
  . 匹配除换行符(/n)外的任何字符
  \d 匹配任意一个0-9的数字
  \w 匹配任意一个数字、字母或下划线
  \s 匹配空白符
  \uhhhh 匹配16进制的unicode码为hhhh的字符 

限定符：
  ? 匹配限定符前面的字符0次或1次
  * ...0次或多次
  + ...1次或多次
  {n} ...n次
  {n,} ...最少n次
  {n,m} ...最少n次,最多m次
  ^str 匹配以str开头的字符串
  str$ 匹配以str结尾的字符串
 零宽断言：零宽度的子表达式匹配,用于查找子表达式匹配的内容之前或之后是否含有特定的字符集
  ?=str 匹配后面紧跟str的字符串
  ?!str 匹配后面不是紧跟str的字符串

运算符优先级：
由高至低：
1.“\”转义符 2.() []括号 3.“* + ？ {n} {n,} {n,m}”限定符 4.“^ $ \d 之类的任何字符及元字符”定位点和序列
5.“|”或操作

子表达式：正则对象包含分组的表达式
正则对象的属性和方法：
 reg为自定义的正则表达式
 检测模式修饰符：
  reg.gobal 判断是否设置了修饰符“g” 若有则返回true
  reg.ignoreCase 判断是否设置了修饰符“i” 若有则返回true
  reg.multiline 判断是否设置了修饰符“m” 若有则返回true
  reg.sourse  返回模式匹配(即reg)文本(去掉了修饰符和定界符)
  reg.lastIndex 返回下一次匹配文本时从哪个字符开始的位置 (需全局匹配的元素才可用此属性,多用于一个字符串多次匹配)
 方法：
  test()判断要检索的字符串内是否有符合要求的正则对象,若有返回true否则返回false  语法：reg.test(str)
  exec()返回匹配的字符串 语法：reg.exec(str) 	
  另exec()有两个方法 exec().index返回匹配的索引 exec().input返回要检索的字符串
  exec()与match()的区别：
  1.用法不同 reg.exec(str)和str.match(reg)
  2.正则无子表达式且非全局匹配,两种方式结果相同均返回第一个匹配的字符串
  3.正则无子表达式且全局匹配,exec()匹配到第一个便终止 match()匹配全局,返回多个元素的数组
  4.正则有子表达式且全局匹配,两者均只匹配第一个便终止 但exec()会增加子表达式匹配 match()则忽略子表达式匹配
  5.正则有子表达式且非全局匹配,两者均只匹配第一个便终止 均增加子表达式匹配 

  综上：exec()只会匹配到第一个元素便终止,且随有无子表达式增加子表达式匹配
  match()全局匹配则忽略子表达式而匹配全局,非全局匹配则随有无子表达式增加子表达式匹配 
  

API即接口函数    Web API即提供给浏览器(BOM)和页面元素(DOM)的函数

BOM(browser object model)浏览器对象
	作用:可以用它移动窗口、改变窗口大小、打开、关闭窗口、弹出对话框等 最大作用:提供了访问html页面的入口---document对象    

	windows.alert()=alert() 只有确认按钮
	confirm() 显示可提示用户输入的对话框,有确认和取消按钮,会返回布尔值1和0
	prompt("语句1","语句2") 语句1为显示窗口提示信息,语句2为默认输入语句 有确认和取消按钮,确认返回"语句2"或“用户输入的语句”。(传入大于两个参数,后面参数无效)取消则返回null

	open() 打开一个新空白窗口
	open("url") 新窗口打开url地址
	open("url1","name") 当有多个open(url,name)时,若name相同则只打开一个,否则都打开
	open("url1","_parent") 效果等同a标签的_self

	常见窗口feature:“width height left top”,不常用:toolbar resizable等
	open("url","name"/"-blank","width= ,height=","left= ,top=")定义窗口宽高及与左上角距离(注意：需有name值或_blank或为空值才能定义宽高,即须有第二个参数,否则浏览器打开的url为全宽高)
	close()关闭窗口

	moveTo(px,px)窗口移动到左上角的距离
	moveBy(px,px)窗口每次移动的距离
	resizeBy(px,px)窗口每次增大或减小(px为负值)的大小
	resizeTo(px,px)窗口增大或减小到(px为负值)





定时器:
	setInterval(function,time) 按照指定周期(毫秒计)调用函数 (注意:调用方法有两种：function,time/'function()',time 另设置一变量对其进行定时和取消操作,否则定时后无法取消)
	setTimeout(function,time) 在指定的时间后(毫秒计)调用函数 (其返回值为number且是一个ID)
	clearInterval()取消定时
	clearTimeout()取消延时

窗口对象： innerWidth 返回窗口文档显示区的宽度
		  innerHeight                  高度   即分辨率

history对象
	history.length  查看浏览器历史记录访问过页面的个数
	history.back()    第一次跳转到此页面的那个url(即相对本页面的上个url),此时返回到上个url 
	history.forward() 此页面第一次跳转到另一个(即下一个)url,此时会再次跳转到那个url 
	history.go(number)   number为正,跳到它的下几页否则为上几页

Location对象的属性
	location.href       设置或返回完整的url
	location.host       设置或返回主机名和当前url的端口号
	location.hostname   设置或返回当前url的主机名
	......

	对象的方法
	location.assign('url')        加载新的文档
	location.reload(true/false)   重新加载当前文档
			无参数/false 检查文档是否已变,若变则重新下载否则从缓存中加载文档
			true  无论文档最后更改日期是何时,均会绕过缓存重新下载
	location.replace()  以新文档替换当前文档(在history中不生成新的历史记录,而是将当前记录替换掉)

Screen对象
	screen.availHeight  screen.availWidth 返回显示屏宽高 （不包含windows任务栏）
	screen.Height  screen.Width 返回显示屏宽高 （包含windows任务栏）
	.......

Navigator对象属性
	appCodeName     返回浏览器代码名
	appMinorVersion 返回浏览器次级版本
	......


document文档对象
	获取HTML文档对象的方法：
	getElementById()        通过ID对象获取 注意：element是单数因为ID唯一 (括号内参数需加'')
	getElementsByName()     通过name对象获取 注意：elements是复数 获取到的对象是个数组
	getElementsByTagName()  通过标签对象获取 注意：elements是复数 获取到的对象是个数组
	getElementsByClassName()  通过类对象获取 注意：IE678不兼容

在HTML DOM中Element对象表示HTML元素
	获取元素内容和标签名称    
	idname/classname/name.innerHTML 返回对应的元素内容  (改写inner对象时需写为如 list.innerHTML="xxx")
	idname/classname/name.tagName   返回对应的元素标签名
	注意：当获取某个元素的class名时,需写为.className

	另一种获取方法
	idname.getAttribute('value/className...')
	idname.setAttribute('属性','属性值') 如原为type=text型,先改为('type','button')
	idname.removeAttribute('属性')

操纵内联样式：需要具体写到某一级
	如background隶属于style 需写成idname.style.background
	带横杠的属性去掉横杠，第二个单词首字母大写如text-shadow需写成textShadow
可以在样式表里定义好类名和样式，然后通过JS将某个元素的类名修改为样式表里的类名


创建HTML文档对象
	createElement() 创建元素节点
	element.appendChild() 向元素添加新的子节点 如：ul1.appendChild('li')
	element.removeChild()从元素中移除子节点

dom节点：将文档结构看成一棵树，每一部分(元素、属性、内容)都可看做一个节点，根据一个节点通过关系可以找到其他节点
	节点的属性（名称、类型、值）
		element.nodeName 返回元素名称 作用同element.tagName
		element.nodeType 返回元素节点类型 如果节点是元素节点则返回1,属性节点返回2,文本节点返回3
		element.nodeValue 设置或返回元素值 文本节点则返回文本内容,属性节点返回属性值,元素节点返回null(因为元素可有嵌套元素)
子元素相关，类似CSS虚拟类别选择器
	element.parentNode
	element.childNodes 返回值为集合


事件处理（添加事件）
	1、HTML事件处理，即内联方式将事件看做标签的一个属性，与HTML混写（如input中添加onclick），但代码不易管理
	2、dom零级事件处理,即脚本方式添加事件，实现HTML与JS分离，但只能添加一个，因为后面的会覆盖前面的。
	3、dom二级事件处理：    
		ele.addEventListener(参数1，参数2，ture/false)添加监听事件
			参数1为触发方式，参数2为要执行的函数 ture/false一般都不写 如('click',myfun1) 注意此时需写为click,不能为onclick
		ele.removeEventListener()移除

鼠标事件：
	onclick单击     ondblclick双击(dbl为double)  onmousedown鼠标按下     onmouseup松开
	onmouseout鼠标从某元素移开  onmouseover鼠标移到某元素上

键盘事件
	onkeydown 某个键盘按键被按下
	onkeyup 某个键盘按键被松开
	onkeypress 某个键盘按键按下并被松开 (经测试，按下未松开时就触发了事件)
	优先顺序 down press up
	区别:press不适用于系统按钮键如：ctr shift alt esc等
		由于event对象包含keycode属性，down和up表示按下的具体的键 press表示按下的字符,即它是区分大小写的
	onload一个页面或一幅图像加载完成
	onunload用户退出页面
	onblur元素失去焦点
	onfocus获得焦点
	onselect文本被选中
	onreset重置按钮被点击
	onscroll文档被滚动
	......
事件的对象：在触发事件时会产生一个事件对象event,这个对象中包含着所有与事件相关的信息，包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。
	event.type      获取事件类型
	event.target    获取事件目标
	event.clientX     {事件被触发时(即配合鼠标进行了单/双击)}返回鼠标指针水平坐标 (相对于整个可见区域的文档)
	event.clientY                           竖直坐标
	event.screenX     事件被触发时返回鼠标指针水平坐标 (相对于用户屏幕)
	event.screenY     (可用document.onclick=myfun进行测试)
	event.keyCode     返回键盘按下的键对应的值
	event.which       返回键盘按下的字符对应的unicode编码值,即ASCII码

	event.ctrlKey     事件触发时ctrl键是否被按下,若被按下,返回值为1 (用onkeydown检测)
	event.shiftKey
	event.altKey

	event.button    鼠标左/中/右哪个键被按下 返回值依次为0/1/2  IE里对应返回1/2/4  此事件应用onmousedown

事件的冒泡和捕获
	冒泡:子级先触发,依次向上传递,直到被点的那一级
	捕获:父级先触发,依次向上传递,直到被点的那一级
	触发方式：添加 addEventListener(触发方式,函数,true/false默认值) true为捕获,false为冒泡
		如:divname.addEventListener('click',myfun,true)
	不是所有事件都能冒泡如：blur、focus、load、unload
	阻止事件冒泡:stopPropagation()   用法：只需在函数内写 event.stopPropagation()即可
	阻止事件默认:preventDefault() 用法同上


JS高级选择器
	document.querySelector('selectors') selectors可为 id/class/标记/兄弟选择器/后代选择器...
		等css中选择器    查找时返回第一个满足条件的元素
	document.querySelectorAll('selectors')selectors可为 id/class/标记/兄弟选择器/后代选择器...
		等css中选择器    查找时返回所有满足条件的元素，返回结果是个集合 注意：查找结果非实时的，即动态添加的查询不到。
	document.getElementsByClassName('selectors') 返回文档中所有指定类名的元素的集合

全局对象
		parseInt()解析一个字符串并返回整数
		parseFloat()解析一个字符串并返回浮点数
		被解析的字符串需以数字开头，否则无法解析；在解析过程中遇到非数字，解析就会结束，只解析未遇到非数字前的那部分
		isNaN(x) 检查参数x是否不是数字，x为非数字则返回true否则false  NaN即 not a number
		常用isNaN()检测parseFloat()和parseInt()解析结果，以判断它们表示的是否是合法数字

变量作用范围
		全局变量：申明在函数之外 优点：变量少，减少形参和实参传递带来的时间消耗  缺点：代码可读性低， 可被多个函数使用，值可能随时发生变化，不利于程序查错和调试

		局部变量：申明在函数体中，并且只能在当前函数体访问

		函数内部定义变量应 定义-赋值-输出 否则会出现逻辑错误  如输出-赋值-定义 函数遇到输出会先执 行定义再回来输出，此时无法输出赋值的结果


return语句外层必须有函数包括，即if语句虽然包括“return”，但if外层仍需有函数包括，否则会发生语法错误
如果函数中包含if语句，if中又包含return,则if下面的代码不会再执行，即“return”可让函数停止运行

</pre>
