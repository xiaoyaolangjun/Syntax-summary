<pre>
第一章:
传统网站存在的问题:
  网速慢时页面加载时间长,用户只能等待
  提交的表单中有有不符合项则需重填所有内容
  页面跳转回重新加载页面,浪费资源

ajax应用场景:
  页面上拉加载更多数据
  列表数据无刷新分页
  表单项失去焦点就可验证数据是否符合要求,如邮箱验证
  搜索框文字提示

运行环境:
  需要在网站环境中才能生效,即localhost,下载express再引入

ajax实现步骤:
  1.创建ajax对象(JS中内置了XMLHttpRequest函数)
    let xhr = new XMLHttpRequest();
  2.告诉ajax请求方式及请求地址
    xhr.open('get','http:...')
  3.发送请求
    xhr.send();
  4.获取服务器端给客户端的响应数据
    xhr.onload = function(){
      console.log(xhr.responseText)
    }

服务器端响应的数据格式:
  在http请求与响应过程中,无论是请求参数还是响应内容,如果是对象类型最终都会被转换成对象字符串进行传输,因此需要将看似是对象的字符串再进行转换
  解析时使用:JSON.parse(str)


获取服务器端的响应:
Ajax状态码:在创建、配置ajax对象,发送请求以及接收完服务器端响应数据,但这个过程中的每一步都会对应一个数值,这个值就是ajax状态码
“0”:请求未初始化(即未调用open())
“1”:请求已建立但未发送(未调用send())
“2”:请求已发送
“3”:请求正在处理中,通常响应中有部分数据可用
“4”:响应已完成可以获取并使用服务器响应
获取http状态码: xhr.status

两种获取服务器端响应数据的方式:
1.onload事件: 无需判断ajax状态码,只被调用一次,代码更简洁,不兼容低版本IE 推荐使用
 xhr.onload = function(){}
2.onreadystatechange: 需要判断ajax状态码,被多次调用,兼容低版本IE 不推荐使用

网络中断会触发onerror事件
 xhr.onerror = function(){}

ajax状态码:表示ajax请求的过程状态,是ajax对象返回的
http状态码:表示请求的处理结果,是服务器端返回的

ajax属于异步请求,程序运行时会先处理后续程序再返回来处理请求函数,即先处理xhr.onload后面的代码

请求参数格式:
  1.application/x-www-form-urlencoded 参数名称=参数值&参数名称=参数值
  2.application/json {参数:参数值}



同源政策:如果两个页面拥有相同的协议、域名和端口号,那么这两个页面就属于同一个源否则就是不同源
解决同源办法:
使用JSONP(json with padding)：它不属于ajax但可模拟ajax请求
  方法:将不同源的服务器端请求地址写在script标签中的src属性中(因为src属性不受同源政策的影响)
  步骤:
  1.引入script标签地址
  2.服务器端响应的数据必须是一个函数的调用且将数据作为实参
  3.客户端在全局作用域下定义函数fn fn需有对应的形参
  4.在客户端函数fn的内部对返回的数据进行处理
  注:步骤1引入的script标签需放在函数后面,另使用jsonp方法需前后端配合,否则前端不知函数如何写及处理

Ajax能给不同源的网站发送请求,不同源的页面也能对请求做出响应,但是响应被浏览器截取了 从而使用script 返回函数调用来解决同源限制的问题



</pre>








